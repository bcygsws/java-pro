package com.nx.to;

/**
 * java_over
 *
 * @author baochengyi
 * @date 2023/2/19 23:13
 * @description
 */
public class MyDate {

}
/*
 *
 * @ Java多态的表现形式：编译时多态 重载 和运行时多态 覆盖
 * 参考文档：https://blog.csdn.net/m0_61933976/article/details/125070919
 *
 * 一、重载：overload,重载是在一个；类中多态性的一种表现，它是在同一个类中定义了多个同名方法，通过定义参数的类型、个数和顺序来实现
 * 1.1 重载是通过方法的参数来区分的，包括参数的个数、类型和顺序
 * 1.2 重载不能通过方法的访问权限、返回值类型和异常类型来实现
 * 1.3 如果一个基类中的方法定义为了private，那么在派生类中对该方法不能达到重载的效果，只是定义了不同的方法（这种情形是重载失效或
 * 不能重载）
 * 注：private方法不能重载、覆盖、不能继承
 *
 * 二、覆盖:override或者重写 overwrite
 * 覆盖是指派生类函数覆盖基类函数。覆盖是对一个方法进行重写，以达到一定的作用
 *
 * 覆盖满足的判断：
 * a.父类和子类有继承关系
 * b.两相同：参数列表和方法名
 * c.一大：访问权限
 * d.一小：返回值类型
 * e.一少：被覆盖方法异常更少
 *
 * 另外：
 * 覆盖只使用非静态方法，静态方法覆盖没有意义
 * 构造函数不能继承，因此构造函数肯定不能覆盖
 * 2.1 派生类中的覆盖方法必须与基类的被覆盖方法有 相同的方法名和参数
 * 2.2 派生类中覆盖方法必须与基类中的被覆盖方法必须有相同返回值类型（如果是引用类型，可以范围更小） 相同或更小
 * 2.3 派生类中的覆盖方法必须与基类中的被覆盖方法必须有相同异常类型（或者是子类） 相同或更少的异常
 * 2.4 派生类中的覆盖方法必须有更高的访问权限  更大访问权限
 *
 * private方法不能覆盖，在子类中即使书写了满足条件的“覆盖方法”，只是新建了一个不同的方法
 *
 * 三、覆盖Object类中的toString()方法
 * 3.1 Ojbect类中toString()的默认实现是：
 *    public String toString() {
 *          return getClass().getName() + "@" + Integer.toHexString(hashCode());
 *    }
 * toString()没有重写时，输出的结果是：类名+@+一个16进制的哈希码
 *
 * 3.2 Object是任何类的基类，因此在创建的任何一个类中书写：public String toString()都是覆盖
 *
 *
 * */